# Gobang-Man-War-Confrontation
## 基于博弈算法的五子棋人机对战
### 程序简介
本程序选用Java作为开发语言，基于博弈算法实现了五子棋的人机对战，并且使用了α-β剪枝算法对博弈树进行了简化，极大地提高了程序下棋的速度。另外，由于博弈算法对未来几步着棋进行了推算，实现了“远谋”，但同时也在一定程度上忽略了本步棋的最佳着棋位置。因此，着棋位置的选择除了有博弈算法的估值，还运用估值函数对当前局面的各位置进行评分。二者综合，实现了下棋的“近虑”和“远谋”。
本程序的五子棋游戏规则是无禁手的，玩家先手。玩家通过输入棋盘坐标下棋（玩家执‘o’棋， 程序执‘x’棋）。

### 操作说明
1. 在命令行窗口上进入程序所在路径，输入“java Main”进入系统主页面
2. 输入棋盘的坐标即可下子，如输入“H H”
玩家在(H,H)上下了棋子，随后程序在(G,G)上下了棋子

### 问题解决思路
为了实现机器的“智能”下棋，本程序采用了极大极小搜索算法建立博弈树，并且用α-β剪枝简化了博弈树，让机器能在五子棋的博弈中寻找最优的走法。
极大极小搜索算法和α-β剪枝通过一个递归函数实现。通过遍历棋盘每一个未有棋子的位置（程序中为了提高下棋的速度，只遍历上一步下子位置周围5格范围内的位置），逐层递归，建立博弈树的结点。博弈树的叶子结点的价值是通过一个估值函数计算的。估值函数参考了网上的一些估值方法，同时做了一些小的修改。得到叶子结点的价值后，将价值往上传递，通过α-β优化策略剪去一些不必要分支。将价值传递到根结点后，通过比较每个位置的根结点价值，选择价值最大的一个位置。
同时，由于人类玩家往往不都是完全理性的，也就是说有的玩家由于水平有限，他的下棋不一定是使对方处于最不利的位置（估值最小），这就使得极大极小搜索算法在现实运用中并不能取得非常好的效果。因此，本程序还用估值函数对本步棋的位置进行估值，将这个值和博弈树得到的价值综合，以此作为下棋的决策。这种综合的方法在实践中确实比单独运用一种方法效果要好。


### 程序设计说明

Main.java	主方法入口	
> + Main方法	提供主方法入口，实现字符界面，检验输入是否合法

ValueMethod.java	集合估值函数的所有方法	ValueMethod类	
> + int AlphaBetaValue(Board board, int x, int y, int depth, int alpha, int beta) -- Alpha-Beta剪枝算法评估
> + int BoardValue(Board board, int x, int y) -- 棋子在(x, y)位置的分数评估（用于alpha-beta剪枝的叶子分数评估）

Board.java	抽象化棋盘	Board类	构造器：
> + Board() -- 无参数构造器
> + Board(int[][] intboard) -- 通过传入int数组棋盘构造Board实例
> + boolean isAvail(int x, int y) -- 判断(x, y)是否有棋子
> + Board setChess(int chess, int x, int y) -- 在(x, y)坐标上放1/2棋子，1代表人，2代表程序
> + String getChess(int x, int y) -- 获得(x, y)坐标上的棋子类型，0代表无棋子，1代表人，2代表程序
> + boolean isFive(int x, int y) -- 判断下了(x, y)坐标的棋子后是否达成五子连珠
> + String int2String(int i) -- 数字转成棋盘字母
> + void showBoard() -- 打印棋盘，+代表无棋子，o代表人，x代表程序

